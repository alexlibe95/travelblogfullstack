# Travel Blog Backend - Cursor Rules & Best Practices

## Project Overview
This is a Parse Server backend built with TypeScript, Express, and MongoDB for a Travel Blog application. The project follows production-ready best practices and is structured for maintainability and scalability.

## Code Style & Formatting

### TypeScript
- Use strict TypeScript settings (`noImplicitAny: true`, `strictNullChecks: true`)
- Always use explicit return types for functions
- Use interfaces for object shapes, types for unions/intersections
- Prefer `const` over `let`, avoid `var`
- Use async/await instead of promises chains
- Always handle errors explicitly, never use empty catch blocks

### Import/Export
- Use ES modules (`import`/`export`)
- Import paths must use `.js` extension (TypeScript ESM requirement)
- Use barrel exports (`index.ts`) for cleaner imports
- Group imports: external packages first, then internal modules

### Naming Conventions
- Files: `camelCase.ts` for utilities, `kebab-case.ts` for components
- Classes: `PascalCase`
- Functions/Variables: `camelCase`
- Constants: `UPPER_SNAKE_CASE`
- Types/Interfaces: `PascalCase` with descriptive names

### Code Organization
- Keep files focused on a single responsibility
- Separate concerns: routes, controllers, services, middleware
- Use middleware for cross-cutting concerns (auth, logging, validation)
- Keep business logic out of route handlers

## Environment Variables

### Required Pattern
- **ALWAYS** use the validated `env` object from `src/utils/env.ts`
- **NEVER** use `process.env` directly with non-null assertions (`!`)
- All environment variables must be validated at startup
- Add new required variables to `src/utils/env.ts` validation

### Example
```typescript
// ❌ BAD
const appId = process.env.APP_ID!;

// ✅ GOOD
import { env } from './src/utils/env.js';
const appId = env.APP_ID;
```

## Error Handling

### Error Middleware Pattern
- Use `ApplicationError` class for application errors
- Use `asyncHandler` wrapper for async route handlers
- Always provide meaningful error messages
- Include appropriate HTTP status codes
- Never expose internal errors in production

### Example
```typescript
import { asyncHandler, ApplicationError } from './src/middleware/errorHandler.js';

app.get('/api/data', asyncHandler(async (req, res) => {
  const data = await fetchData();
  if (!data) {
    throw new ApplicationError('Data not found', 404);
  }
  res.json(data);
}));
```

## Security Best Practices

### CORS & Headers
- Use security middleware from `src/middleware/security.ts`
- Configure `ALLOWED_ORIGINS` for production
- Never use `*` for CORS in production
- Always set security headers (X-Frame-Options, CSP, etc.)

### Parse Server Security
- Never expose master key in client code
- Use role-based permissions in schema definitions
- Validate all user inputs
- Sanitize file uploads
- Use HTTPS in production

### Dashboard Security
- Only allow insecure HTTP in development
- Use strong passwords for dashboard access
- Consider IP restrictions for production

## Parse Server Patterns

### Cloud Functions
- Define all cloud functions in `cloud/main.ts`
- Use descriptive function names
- Always handle errors in cloud functions
- Document function parameters and return types
- Use async/await for asynchronous operations

### Schema Definitions
- Define schemas in `cloud/schema.ts`
- Use strict schema validation (`strict: true`)
- Lock schemas in production (`lockSchemas: true`)
- Set appropriate class-level permissions
- Document field purposes in comments

### Example Schema
```typescript
{
  className: 'MyClass',
  fields: {
    name: { type: 'String', required: true },
    // Add field documentation
  },
  classLevelPermissions: {
    find: { '*': true },
    create: { 'role:Admin': true },
    // Set appropriate permissions
  },
}
```

## Express Middleware

### Middleware Order
1. Security headers
2. CORS
3. Body parsing
4. Static files
5. Routes
6. 404 handler
7. Error handler (last)

### Custom Middleware
- Place in `src/middleware/`
- Export as named exports
- Use TypeScript types for Request/Response
- Handle errors appropriately

## Testing (When Added)

### Unit Tests
- Test utilities and pure functions
- Mock external dependencies
- Use descriptive test names
- Follow AAA pattern (Arrange, Act, Assert)

### Integration Tests
- Test API endpoints
- Test Parse Server interactions
- Use test database
- Clean up after tests

## File Structure Conventions

```
src/
├── middleware/     # Express middleware
├── utils/          # Utility functions
├── services/       # Business logic (if needed)
└── types/          # TypeScript type definitions

cloud/
├── main.ts        # Cloud functions
└── schema.ts      # Schema definitions

constants/         # Application constants
```

## Git & Version Control

### Commit Messages
- Use descriptive commit messages
- Follow conventional commits format
- Reference issue numbers when applicable

### .gitignore
- Never commit `.env` files
- Ignore `dist/`, `node_modules/`, `logs/`
- Keep `.env.example` in repository

## Documentation

### Code Comments
- Use JSDoc for public functions
- Explain "why" not "what" in comments
- Keep comments up-to-date with code changes

### README
- Keep README.md updated with project changes
- Document all environment variables
- Include setup and deployment instructions

## Performance Considerations

### Database Queries
- Use indexes for frequently queried fields
- Limit query results when possible
- Use `select` to fetch only needed fields
- Avoid N+1 query problems

### Parse Server
- Use Cloud Functions for complex operations
- Cache frequently accessed data when appropriate
- Optimize file uploads (use thumbnails)
- Monitor query performance

## Logging

### Current State
- Using `console.log` (acceptable for development)
- Consider structured logging (Winston/Pino) for production

### Logging Best Practices
- Use appropriate log levels (info, warn, error)
- Include context in log messages
- Never log sensitive information (passwords, tokens)
- Use structured logging format

## Deployment Checklist

Before deploying to production:
- [ ] All environment variables set and validated
- [ ] `NODE_ENV=production`
- [ ] HTTPS configured
- [ ] CORS origins configured
- [ ] Dashboard secured (HTTPS only)
- [ ] Error handling tested
- [ ] Health check endpoint working
- [ ] Graceful shutdown tested
- [ ] Database backups configured
- [ ] Monitoring set up

## Common Patterns

### Async Route Handler
```typescript
import { asyncHandler } from './src/middleware/errorHandler.js';

app.get('/route', asyncHandler(async (req, res) => {
  // Your async code
}));
```

### Environment Variable Access
```typescript
import { env } from './src/utils/env.js';

const value = env.VARIABLE_NAME;
```

### Error Throwing
```typescript
import { ApplicationError } from './src/middleware/errorHandler.js';

throw new ApplicationError('Error message', 400);
```

### Parse Query
```typescript
import Parse from 'parse/node.js';

const query = new Parse.Query('MyClass');
const results = await query.find();
```

## Anti-Patterns to Avoid

### ❌ Don't Do This
- Using `process.env.VAR!` directly
- Empty catch blocks
- `any` types without good reason
- Console.log in production code (use proper logging)
- Hardcoded values (use constants/env vars)
- Ignoring TypeScript errors
- Exposing sensitive data in errors
- Using `eval()` or `Function()` constructor
- Synchronous operations in request handlers
- Not handling promise rejections

### ✅ Do This Instead
- Use validated `env` object
- Handle errors appropriately
- Use proper types
- Use structured logging
- Extract magic numbers/strings to constants
- Fix TypeScript errors properly
- Sanitize error messages
- Use safe alternatives
- Use async/await
- Always catch promise rejections

## Code Review Checklist

When reviewing code, check for:
- [ ] Environment variables use validated `env` object
- [ ] Errors are handled properly
- [ ] TypeScript types are correct
- [ ] Security best practices followed
- [ ] No hardcoded secrets or credentials
- [ ] Code follows naming conventions
- [ ] Comments explain complex logic
- [ ] No console.log in production code
- [ ] Async operations use asyncHandler
- [ ] Parse queries are optimized

## Resources

- Parse Server Docs: https://docs.parseplatform.org/
- TypeScript Handbook: https://www.typescriptlang.org/docs/
- Express Best Practices: https://expressjs.com/en/advanced/best-practice-security.html
- Node.js Best Practices: https://github.com/goldbergyoni/nodebestpractices

